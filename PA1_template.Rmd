---
title: "Reproducible Research: Peer Assessment 1"
output: 
  html_document:
    keep_md: true
---


## Loading and preprocessing the data
```{r}
library(magrittr)
library(dplyr)
library(lubridate)
library(tidyr)
library(ggplot2)

activityDf <- read.csv('activity.csv', colClasses=c('integer', 'character', 'numeric'), stringsAsFactors=F) %>%
{
    .$date <- ymd(.$date)
    .
} 
```

## What is mean total number of steps taken per day?


To do so we are going to create a new column which is simply the day of the year for a given date. The code will then group by day of year and sum the steps for each day.

```{r}
stepsByDayDf <- activityDf %>%
    group_by(dayOfYear = yday(.$date)) %>%
    summarise(totalSteps = sum(steps)) %>% {
        meanStepsPerDay <<- mean(.$totalSteps, na.rm=T )
        medianStepsPerDay <<- median(.$totalSteps, na.rm=T)
        . #Return the dataset    
    }
    

```

Our mean and median steps per day is : `r trunc(meanStepsPerDay)` and `r medianStepsPerDay`

We also can confirm this with the histogram. Noting that the highest frequency of days is for steps in the range 10,000 to 15,000 and the center of that range is 12500 which closely approximates our computed mean and median values.

```{r}
hist(stepsByDayDf$totalSteps, breaks = "Sturges",
     ylab='Frequency in Days', xlab='Step ranges',
     main = 'Occurrences of days for given step range',
     col='peachpuff', border='red')
```


## What is the average daily activity pattern?
To answer this question the code below has been written to transform the narrow / tidy data set to a wide format, where each row represents all interval observations of a given day.  This is accomplished by use of the spreading function from the tidyr package. Once the data are transformed it is then trivial to compute the mean of the daily interval columns. 

It is important note that the raw data points for the interval variable is actually a stepwise function of time.  By stepwise I mean its value repeats according to the modulus of a sequential 5 minute timer.  ie the 2 least significant digits roll over to zero on 60 minute boundaries. Hence the interval variable is modulo 60 and therefore should not be used as the input x scale of a plotting, lest the plot be distorted by the nature of the step. For this reason we are going to create a new interval variable that is a linear sequence of 5 minute intervals, so that we may plot correctly without skew, but still label the x axis according to clock time interval that is given in the raw data.

```{r}
dailyIntervals <- activityDf %>% spread(interval, steps )
intervalSummary <- data.frame(meanStepsOverAllDays =
    sapply(dailyIntervals[,2:ncol(dailyIntervals)],
           function(x) mean(x, na.rm=T)),
    sequentialperoid = seq(0, 1435, by=5),
    clockperiod = names(dailyIntervals[,2:ncol(dailyIntervals)]))

maxIntervalStepsIndex <- which.max(intervalSummary$meanStepsOverAllDays)

clockIntervalWithMaximumSteps <-
    intervalSummary$clockperiod[maxIntervalStepsIndex]
sequential5MinIntervalWtihMaximumSteps <- 
    intervalSummary$sequentialperoid[maxIntervalStepsIndex]
```

The code above also locates the row index `r maxIntervalStepsIndex` where we have the maximum number of steps over the 24 hours of the averaged daily steps. With this index we can then find both the clock time (raw data interval) and the sequential 5 minute interval of the 24 hour period.

The clock interval with Maximum Steps is `r clockIntervalWithMaximumSteps`

The corresponding Sequential 5-Minuite interval with Maximum Steps is `r sequential5MinIntervalWtihMaximumSteps`

```{r}
p <- ggplot(intervalSummary, aes(x = sequentialperoid, y = meanStepsOverAllDays )) +
    geom_line(col='blue') +
    ggtitle("Mean Steps / Day") +
    scale_x_continuous(
        breaks=c(0, 250, 500, 750, 1000, 1250, 1500),
        labels=c('0','4:10', '8:20', '12:30', '16:40', '20:50', '25:00')) +
    labs(x='24Hr Time HH:MM', y='Mean steps per interval over all days.')
p
```


## Imputing missing values


## Are there differences in activity patterns between weekdays and weekends?
This code transform the dailyIntervals data frame from the computations above
by adding a new factor variable for the dayType of 'weekday' or 'weekend'.
The subsequent group_by and summarise_each functions creates the mean steps
per day for each day type of a given date.

Finally, the code prepares the data to be plotted, by creating a more tidy ('narrow')
data set using the gather function. The resulting structure allows for simple plotting
by variable name. Again, as in the above plot, I'm going to add a new variable that
represents the sequential 5 minute interval to use as the x axis in the plot,
so as to prevent a skewed plot if we had chosen to use the modulo 60 interval variable 
of the underlying raw data set.


```{r}
dayTypeSummary <- dailyIntervals %>%
    #Start by adding a new column for the day type to the dailyIntervals dataFrame
    mutate(dayType = factor(
        ifelse(wday(.$date) == 1 | wday(.$date) == 7,"weekend","weekday"))
    ) %>%
    group_by(dayType) %>%
    #Summarize along all the interval varibles. 
    #Do so by specifying what not to summarize
    summarise_each(funs(mean(., na.rm=T)), -c(date, dayType)) %>%
    #Narrow the dataset from the wide format we started with
    gather(dayType) %>%
    {
        names(.) <- c('dayType', 'clockinterval', 'avgsteps')
        .
    } %>%
    #Again, we add the sequentialIntervarible to be used as the x Axis
    # to prevent the clock interval of the raw data from skewing the plot.
    mutate(sequentialInterval = rep(seq(0, 1435, by=5), each=2 ))

ggplot(dayTypeSummary, aes(x=sequentialInterval, y=avgsteps, group=dayType)) + 
    geom_line() + facet_grid(dayType ~ .) + scale_x_continuous(
        breaks=c(0, 250, 500, 750, 1000, 1250, 1500),
        labels=c('0','4:10', '8:20', '12:30', '16:40', '20:50', '25:00')) +
    labs(x='24Hr Time HH:MM', y='Mean steps per interval over days of group.')
```

